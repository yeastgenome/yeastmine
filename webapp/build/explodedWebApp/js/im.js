// Generated by CoffeeScript 1.3.3
(function() {
  var root;

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = initValue != null ? initValue : xs.pop();
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === "undefined" || exports === null) {
    root._func_shiv = {};
    root = root._func_shiv;
  }

  root.fold = function(init, f) {
    return function(xs) {
      var k, ret, v;
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, (n - 1) + 1 || 9e9);
      } else {
        return xs;
      }
    };
  };

  root.omap = function(f) {
    return function(o) {
      var domap;
      domap = exports.fold({}, function(a, k, v) {
        var kk, vv, _ref;
        _ref = f(k, v), kk = _ref[0], vv = _ref[1];
        a[kk] = vv;
        return a;
      });
      return domap(o);
    };
  };

  root.partition = function(f) {
    return function(xs) {
      var falses, trues, x, _i, _len;
      trues = [];
      falses = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          trues.push(x);
        } else {
          falses.push(x);
        }
      }
      return [trues, falses];
    };
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, k, ret, v, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = (function() {
          if (ret === void 0) {
            return fx;
          } else if (typeof fx === 'string') {
            return ret + fx;
          } else if (fx.slice != null) {
            return ret.concat(fx);
          } else {
            for (k in fx) {
              v = fx[k];
              ret[k] = v;
            }
            return ret;
          }
        })();
      }
      return ret;
    };
  };

  root.AND = function(a, b) {
    return a && b;
  };

  root.OR = function(a, b) {
    return a || b;
  };

  root.NOT = function(x) {
    return !x;
  };

  root.id = function(x) {
    return x;
  };

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    var _, Deferred;
    if (IS_NODE) {
        _ = require('underscore')._;
        Deferred = require('jquery-deferred').Deferred;
    } else {
        _ = exports._;
        Deferred = exports.jQuery.Deferred;
        if (typeof exports.intermine === 'undefined') {
            exports.intermine = {};
        }
        exports = exports.intermine;
    } 

    var PathInfo = function(info) {
        _(this).extend(info);
        this.end = _(this.descriptors).last();
    };
    PathInfo.prototype.constructor = PathInfo;

    PathInfo.prototype.isRoot = function() {
        return this.descriptors.length == 0;
    };

    PathInfo.prototype.getEndClass = function() {
        if (this.isRoot()) {
            return this.root;
        }
        if (this.isClass()) {
            return this.model.classes[this.end.referencedType];
        }
        return null;
    };

    PathInfo.prototype.getParent = function() {
        if (this.isRoot()) {
            throw "Root paths do not have a parent";
        }
        var data = _.extend({}, this, {descriptors: _(this.descriptors).initial()});
        return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
        var type = this.getType();
        if (_(attr).isString()) {
            attr = type.fields[attr];
        }
        var data = _.extend({}, this, {descriptors: this.descriptors.concat([attr])});
        return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
        var className = (clazz.name) ? clazz.name : clazz + "";
        var type = this.getType();
        var ancestors;
        if (className === type.name) {
            return true;
        } else {
            ancestors = this.model.getAncestorsOf(type);
            return _(ancestors).include(className);
        }
    };

    var _displayNameCache = {};

    PathInfo.prototype.getDisplayName = function(cb) {
        var wrapped, self = this;
        var cacheKey = this.toString() + ":" + _.map(this.subclasses, function(v, k) {return k + "=" + v}).join(';');
        var displayName;
        if (_displayNameCache[cacheKey] != null) {
            promise = new Deferred();
            displayName = _displayNameCache[cacheKey];
            if (cb != null) {
                cb(displayName);
            }
            promise.resolve(displayName);
            return promise;
        }
            this.displayName = _displayNameCache[cacheKey];
        if (cb == null) {
            wrapped = function() {};
        } else {
            wrapped = function(resp) {
                self.displayName = resp.display;
                _displayNameCache[cacheKey] = resp.display;
                cb(resp.display);
            };
        }
        if (this.model.service == null) {
            throw new Error("Cannot fetch display name: no service");
        }
        var params = {format: 'json'};
        _.each(this.subclasses, function(v, k) {
            params[k] = v;
        });
        var slashPath = _.reduce(this.descriptors, function(a, d) { return a + "/" + d.name }, "/" + this.root.name);
        return this.model.service.makeRequest('model' + slashPath, params, wrapped);
    };

    PathInfo.prototype.getChildNodes = function() {
        var cls, flds, childNodes, i, l;
        childNodes = [];
        var self = this;
        if (!this.isAttribute()) {
            cls = this.getEndClass();
            flds = cls.fields;
            _.each(flds, function(fld, name) {
                childNodes.push(self.append(fld));
            });
        } 
        return childNodes;
    };


    var pistr = function() {
        var str = this.root.name;
        return _(this.descriptors).reduce(function(a, b) {return a + "." + b.name}, this.root.name);
    };

    PathInfo.prototype.toPathString = pistr;
    PathInfo.prototype.toString = pistr;

    PathInfo.prototype.isAttribute = function() {
        if (this.isRoot()) {
            return false;
        }
        return this.end && !this.end.referencedType;
    };


    PathInfo.prototype.isClass = function() {
        if (this.isRoot()) {
            return true;
        }
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isReference = function() {
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isCollection = function() {
        return this.end && this.end.isCollection;
    };

    PathInfo.prototype.containsCollection = function() {
        if (this.isRoot()) {
            return false;
        }
        return _(this.descriptors).any(function(d) {
            return d.isCollection;
        });
    };

    var Table = function(o) {
        _(this).extend(o);
        _(this.collections).each(function(coll) {
            coll.isCollection = true;
        });
        this.fields = _({}).extend(this.attributes, this.references, this.collections);
        this.allReferences = _({}).extend(this.references, this.collections);
    };

    // TODO: write unit tests.
    /**
        * Get the type of an attribute path. If the path represents a class or a reference, 
        * the class itself is returned, otherwise the name of the attribute type is returned, 
        * minus any "java.lang." prefix.
        *
        * @param path The path to get the type of
        * @return A class-descriptor, or an attribute type name.
        */
    PathInfo.prototype.getType = function() {
        return this.getEndClass() || this.end.type.replace(/java\.lang\./, "");
    };

    Table.prototype = {
        constructor: Table
    };

    Table.prototype.toString = function toString() {
        return "[Table name=" + this.name + "]"
    };

    var Model = function(model) {
        _(this).extend(model);

        // Promote classes to tables.
        var classes = this.classes;
        _(classes).each(function(cd, name) {
            classes[name] = new Table(cd);
        });

    };

    Model.prototype.constructor = Model;

    /**
    * Get the ClassDescriptor for a path. If the path is a root-path, it 
    * returns the class descriptor for the class named, otherwise it returns 
    * the class the last part resolves to. If the last part is an attribute, this
    * function returns "undefined".
    *
    * @param path The path to resolve.
    * @return A class descriptor object, or undefined.
    */
    Model.prototype.getCdForPath = function(path) {
        var parts = path.split(".");
        var cd = this.classes[parts.shift()];
        return _(parts).reduce(_(function (memo, fieldName) {
            var fields = _({}).extend(
                memo.attributes, memo.references, memo.collections);
            return this.classes[fields[fieldName].referencedType];
        }).bind(this), cd);
    };

    // TODO: write unit tests
    /**
        * Get an object describing the path defined by the arguments.
        *
        * @param path The path to be described.
        * @param subclasses An object mapping path {Str} -> type {Str}
        */
    Model.prototype.getPathInfo = function(path, subclasses) {
        var cacheKey, pathInfo, parts, cd, keyPath, ret, self = this;
        subclasses = subclasses || {};
        cacheKey = path + _.map(subclasses, function(v,k) {return k+"="+v; }).join(':');
        if (this.__pathinfos == null) {
            this.__pathinfos = {};
        }
        if (this.__pathinfos[cacheKey] != null) {
            return this.__pathinfos[cacheKey];
        }
        pathInfo = {};
        parts = path.split(".");
        cd = this.classes[parts.shift()];
        keyPath = cd.name;
        pathInfo.root = cd;
        pathInfo.model = this;
        pathInfo.descriptors = _(parts).map(function(fieldName) {
            var fields = _({}).extend(cd.attributes, cd.references, cd.collections);
            if (!fields[fieldName]) {
                cd = self.classes[subclasses[keyPath]];
                try {
                    fields = _({}).extend(cd.attributes, cd.references, cd.collections);
                } catch (e) {
                    throw new Error("Could not resolve " + path);
                }
            }
            keyPath += "." + fieldName;
            var fd = fields[fieldName];
            cd = fd.referencedType ? self.classes[fd.referencedType] : null;
            return fd;
        });
        pathInfo.subclasses = subclasses;

        ret = new PathInfo(pathInfo);
        this.__pathinfos[cacheKey] = ret;
        return ret;

    };



    // TODO: write unit tests.
    // TODO - move all uses to PathInfo
    /**
        * Determine if there are any collections mentioned in the given path. 
        * eg: 
        *   Department.employees.name -> true
        *   Department.company.name -> false
        *
        * @param path {String} The path to examine.
        * @return {Boolean} Whether or not there is any collection in the path.
        */
    Model.prototype.hasCollection = function(path) {
        var paths = []
            ,parts = path.split(".")
            ,bit, parent, cd;
        while (bit = parts.pop()) {
            parent = parts.join(".");
            if ((parent) && (cd = this.getCdForPath(parent))) {
                if (cd.collections[bit]) {
                    return true;
                }
            }
        }
        return false;
    };

    var _subclass_map = {};

    /**
        * Return the subclasses of a given class. The subclasses of a class
        * includes the class itself, and is thus equivalent to 
        * 'isAssignableTo' in java.
        */
    Model.prototype.getSubclassesOf = function(cls) {
        var self = this;
        if (cls in _subclass_map) {
            return _subclass_map[cls];
        }
        var ret = [cls];
        _(this.classes).each(function(c) {
            if (_(c["extends"]).include(cls)) {
                ret = ret.concat(self.getSubclassesOf(c.name));
            }
        });
        _subclass_map[cls] = ret;
        return ret;
    };

    /**
    * Get the full ancestry of a particular class.
    *
    * The returned ancestry never includes the root InterMineObject base class.
    */
    Model.prototype.getAncestorsOf = function(clazz) {
        clazz = (clazz && clazz.name) ? clazz : this.classes[clazz + ""];
        var ancestors = clazz["extends"].slice();
        _(ancestors).each(_(function(a) {
            if (!a.match(/InterMineObject$/)) {
                ancestors = _.union(ancestors, this.getAncestorsOf(a));
            }
        }).bind(this));
        return ancestors;
    }


    /**
    * Return the common type of two model classes, or null if there isn't one.
    */
    Model.prototype.findCommonTypeOf = function(classA, classB) {
        if (classB == null || classA == null || classA == classB) {
            return classA;
        }
        var allAncestorsOfA = this.getAncestorsOf(classA);
        var allAncestorsOfB = this.getAncestorsOf(classB);
        // If one is a superclass of the other, return it.
        if (_(allAncestorsOfA).include(classB)) {
            return classB;
        }
        if (_(allAncestorsOfB).include(classA)) {
            return classA;
        }
        // Return the first common ancestor

        return _.intersection(allAncestorsOfA, allAncestorsOfB).shift();
    };

    /**
    * Return the common type of 0 or more model classes, or null if there is none.
    *
    * @param model The data model for this service.
    * @classes {String[]} classes the model classes to try and get a common type of.
    */
    Model.prototype.findCommonTypeOfMultipleClasses = function(classes) {
        return _.reduce(classes, _(this.findCommonTypeOf).bind(this), classes.pop());
    };
    Model.NUMERIC_TYPES = ["int", "Integer", "double", "Double", "float", "Float"];
    Model.INTEGRAL_TYPES = ["int", "Integer"]
    Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

    exports.Model = Model;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');

"use strict";

(function(exports, IS_NODE) {

    var Model, Query, List, _, Deferred;
    if (IS_NODE) {
        _ = require('underscore')._;
        Deferred = require('jquery-deferred').Deferred;
        var http     = require('http');
        var URL      = require('url');
        var qs       = require('querystring');
        Model        = require('./model').Model;
        Query        = require('./query').Query;
        List         = require('./lists').List;
        var EventEmitter = require('events').EventEmitter;
        var BufferedResponse = require('buffered-response').BufferedResponse;
    } else {
        _ = exports._;
        Deferred = exports.jQuery.Deferred;
        if (typeof exports.intermine === 'undefined') {
            exports.intermine = {};
        }
        exports = exports.intermine;
    } 

    var to_query_string = IS_NODE ? qs.stringify : jQuery.param;

    var MODELS = {};
    var SUMMARY_FIELDS = {};
    var slice = Array.prototype.slice;
    var DEFAULT_PROTOCOL = "http://";
    var VERSION_PATH = "version";
    var TEMPLATES_PATH = "templates";
    var LISTS_PATH = "lists";
    var MODEL_PATH = "model";
    var SUMMARYFIELDS_PATH = "summaryfields";
    var QUERY_RESULTS_PATH = "query/results";
    var QUICKSEARCH_PATH = "search";
    var WIDGETS_PATH = "widgets";
    var ENRICHMENT_PATH = "list/enrichment";
    var WITH_OBJ_PATH = "listswithobject";
    var LIST_OPERATION_PATHS = {
        merge: "lists/union",
        intersect: "lists/intersect",
        diff: "lists/diff"
    };

    var Service = function(properties) {

        if (typeof Model === 'undefined' && intermine) {
            Model = intermine.Model;
        }
        if (typeof Query === 'undefined' && intermine) {
            Query = intermine.Query;
        }
        if (typeof List === 'undefined' && intermine) {
            List = intermine.List;
        }

        var getResulteriser = function(cb) { return function(data) {
            cb = cb || function() {};
            cb(data.results, data);
        }};

        var getFormat = function(def) {
            var format = def || "json";
            if (!(IS_NODE || jQuery.support.cors)) {
                format = format.replace("json", "jsonp");
            }
            return format;
        };

        /**
        * Performs a get request for data against a url. 
        * This method makes use of jsonp where available.
        */
        this.makeRequest = function(path, data, cb, method, itemByItem) {
            var url   = this.root + path;
            var errorCB = this.errorHandler;
            data = data || {};
            cb = cb || function() {};
            if (this.token) {
                data.token = this.token;
            }
            var dataType = "json";
            data.format = getFormat(data.format);

            if (_(cb).isArray()) {
                errorCB = cb[1];
                cb = cb[0];
            }

            if (!(IS_NODE || jQuery.support.cors)) {
                data.method = method;
                method = false; 
                url += "?callback=?";
                dataType = "jsonp";
                console.log("No CORS support: going for jsonp");
            } else if (IS_NODE && !method) {
                method = "GET";
            }

            if (method) {
                if (method === "DELETE") {
                    // grumble grumble struts grumble grumble...
                    url += "?" + to_query_string(data);
                }
                return this.doReq({
                    data: data,
                    dataType: "json",
                    success: cb,
                    error: errorCB,
                    url: url,
                    type: method
                }, itemByItem);
            } else {
                return jQuery.getJSON(url, data, cb);
            }
        };

        if (IS_NODE) {
            this.rowByRow = function(q, page, cbs) {
                // Allow calling as rows(q, cb)
                if (_(cbs).isUndefined() && _(page).isFunction()) {
                    cbs = page;
                    page = {};
                }
                page = page || {};
                var req = _(page).extend({query: q.toXML()});
                return this.makeRequest(QUERY_RESULTS_PATH, req, cbs, 'POST', true);
            };

            this.recordByRecord = function(q, page, cbs) {
                // Allow calling as records(q, cb)
                if (_(cbs).isUndefined() && _(page).isFunction()) {
                    cbs = page;
                    page = {};
                }
                page = page || {};
                var req = _(page).extend({query: q.toXML(), format: "jsonobjects"});
                return this.makeRequest(QUERY_RESULTS_PATH, req, cbs, 'POST', true);
            };

            var PESKY_COMMA = /,\s*$/;

            var __doIterableReq = function(ret, opts) { return function(res) {
                 var iter, containerBuffer = "";
                 var char0 = (opts.data.format === 'json') ? '[' : '{';
                 var charZ = (opts.data.format === 'json') ? ']' : '}';
                 iter = new BufferedResponse(res, 'utf8')
                    .map(function(line, idx) {
                        try {
                          var parsed = JSON.parse(line.replace(PESKY_COMMA, ''));
                          return parsed;
                        } catch(e) {
                          containerBuffer += line;
                          var lastChar = line[line.length - 1];
                          if (idx > 0 && (lastChar === ',' || (lastChar === char0 && line[0] === charZ))) {
                              iter.emit('error', e, line); // should have parsed.
                          }
                          return undefined;
                        }
                    })
                   .filter(function(item) {return (!!item)})
                   .each(function(item) {
                       try {
                           opts.success(item);
                       } catch (e) {
                           iter.emit('error', e);
                           ret.reject(e);
                       }
                    })
                   .error(opts.error)
                   .done(function() {
                     try {
                         var container = JSON.parse(containerBuffer);
                         if (container.error) {
                             var e = new Error("Server reported error: " + container.error + ", " + container.statusCode);
                             ret.reject(e);
                             iter.emit('error', e);
                         }
                     } catch (e) {
                         ret.reject(e, containerBuffer);
                         iter.emit('error', containerBuffer);
                     }
                   });
                ret.resolve(iter);
            }};
            var __doSingletonResult = function(ret, opts) { return function(res) {
                 var contentBuffer = "";
                 ret.then(opts.success);
                 res.on('data', function(chunk) {contentBuffer += chunk});
                 res.on('end', function() {
                     if (opts.data.format.match(/json/)) {
                        var parsed;
                        try {
                            parsed = JSON.parse(contentBuffer);
                            if (parsed.error) {
                                var error = new Error("When running " + JSON.stringify(opts.data) + ": " + parsed.error);
                                ret.reject(error, parsed.status);
                            } else {
                                ret.resolve(parsed);
                            }
                        } catch(e) {
                            ret.reject(new Error("Could not parse buffer (" + contentBuffer + "): " + e));
                        }
                     } else {
                         var e;
                         if (e = contentBuffer.match(/\[Error\] (\d+)(.*)/m)) {
                             ret.reject(new Error(e[2], e[1]));
                         } else {
                             ret.resolve(contentBuffer);
                         }
                     }
                 });
            }}

            this.doReq = function(opts, resultByResult) {
                var ret = new Deferred().fail(opts.error);
                var postdata = to_query_string(opts.data);
                var url = URL.parse(opts.url, true);
                url.method = opts.type;
                url.port = url.port || 80;
                url.headers = {'User-Agent': 'node-http/imjs'};
                if (url.method === 'GET' && _(opts.data).size()) {
                    url.path += "?" + postdata;
                } else if (url.method === 'POST') {
                    url.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    url.headers['Content-Length'] = postdata.length;
                }
                var req = http.request(url, (resultByResult) ?
                    __doIterableReq(ret, opts) : __doSingletonResult(ret, opts));

                req.on('error', function(e) {
                    ret.reject(e);
                });

                if (url.method === 'POST') {
                    if (this.DEBUG) {
                        console.log("Writing data to " + url.host + "/" + url.path + ": " + postdata);
                    }
                    req.write(postdata);
                }
                req.end();
                return ret;
            };
        } else {
            this.doReq = function(opts) {
                return jQuery.ajax(opts);
            }
            var __wrap_cbs = function(cbs) {
                var wrappedSuccess, error;
                if (_.isArray(cbs)) {
                    wrappedSuccess = function(rows) {
                        _.each(rows, cbs[0]);
                    };
                    error = cb[1];
                    return [wrappedSuccess, error];
                } else {
                    wrappedSuccess = function(rows) {
                        _.each(rows, cbs);
                    };
                    return wrappedSuccess;
                }
            };
            this.rowByRow = function(q, page, cbs) {
                var _cbs = __wrap_cbs(cbs);
                page = page || {};
                var req = _(page).extend({query: q.toXML()});
                return this.makeRequest(QUERY_RESULTS_PATH, req, _cbs, 'POST');

            };
            this.recordByRecord = function(q, page, cbs) {
                var _cbs = __wrap_cbs(cbs);
                page = page || {};
                var req = _(page).extend({query: q.toXML(), format: "jsonobjects"});
                return this.makeRequest(QUERY_RESULTS_PATH, req, _cbs, 'POST');

            };
        }
        this.eachRow = this.rowByRow;
        this.eachRecord = this.recordByRecord;

        this.widgets = function(cb) {
            cb = cb || _.identity;
            return this.makeRequest(WIDGETS_PATH, null, function(data) {
                cb(data.widgets);
            });
        };

        this.enrichment = function(req, cb) {
            cb = cb || _.identity;
            _.defaults(req, {maxp: 0.05});
            return this.makeRequest(ENRICHMENT_PATH, req, function(data) {cb(data.results)});
        };

        this.search = function(options, cb) {
            if (_(options).isString()) {
                options = {term: options};
            }
            if (!cb && _(options).isFunction()) {
                cb = options;
                options = {};
            }
            options = options || {};
            cb      = cb      || function() {};
            _.defaults(options, {term: "", facets: {}});
            var req = {q: options.term, start: options.start, size: options.size};
            if (options.facets) {
                _(options.facets).each(function(v, k) {
                    req["facet_" + k] = v;
                });
            }
            return this.makeRequest(QUICKSEARCH_PATH, req, function(data) {
                cb(data.results, data.facets);
            }, "POST");
        };

        this.count = function(q, cont) {
            var req = {
                query: q.toXML(),
                format: (IS_NODE || jQuery.support.cors) ? "jsoncount" : "jsonpcount"
            };
            var promise = Deferred();
            this.makeRequest(QUERY_RESULTS_PATH, req, function(data) {
                if (cont) 
                    cont(data.count);
                promise.resolve(data.count);
            }).fail(promise.reject);
            promise.fail(this.errorHandler);
            return promise;
        };

        this.findById = function(table, objId, cb) {
            this.query({from: table, select: ["**"], where: {"id": objId}}, function(q) {
                q.records(function(rs) {
                    cb(rs[0]);
                });
            });
        };

        this.whoami = function(cb) {
            cb = cb || function() {};
            var self = this;
            var promise = Deferred();
            self.fetchVersion(function(v) {
                if (v < 9) {
                    var msg = "The who-am-i service requires version 9, this is only version " + v;
                    promise.reject("not available", msg);
                } else {
                    self.makeRequest("user/whoami", null, function(resp) {cb(resp.user)})
                        .then(promise.resolve, promise.reject);
                }
            });
            return promise;
        };

        this.table = function(q, page, cb) {
            page = page || {};
            var req = _(page).extend({
                query: q.toXML(), 
                format: "jsondatatable"
            });
            return this.makeRequest(QUERY_RESULTS_PATH, req, getResulteriser(cb), "POST");
        };

        this.records = function(q, page, cb) {
            // Allow calling as records(q, cb)
            if (_(cb).isUndefined() && _(page).isFunction()) {
                cb = page;
                page = {};
            }
            page = page || {};
            var req = _(page).extend({query: q.toXML(), format: (IS_NODE || jQuery.support.cors) ? "jsonobjects" : "jsonpobjects"});
            return this.makeRequest(QUERY_RESULTS_PATH, req, getResulteriser(cb), 'POST');
        };

        this.rows = function(q, page, cb) {
            // Allow calling as rows(q, cb)
            if (_(cb).isUndefined() && _(page).isFunction()) {
                cb = page;
                page = {};
            }
            page = page || {};
            var req = _(page).extend({query: q.toXML()});
            return this.makeRequest(QUERY_RESULTS_PATH, req, getResulteriser(cb), 'POST');
        };

        this.tableRows = function(q, page, cb) {
            // Allow calling as records(q, cb)
            if (_(cb).isUndefined() && _(page).isFunction()) {
                cb = page;
                page = {};
            }
            page = page || {};
            var req = _(page).extend({query: q.toXML(), format: "json"});
            return this.makeRequest(QUERY_RESULTS_PATH + "/tablerows", req, getResulteriser(cb), 'POST');
        };


        var constructor = _.bind(function(properties) {
            var root = properties.root;
            if (root && !/^https?:\/\//i.test(root)) {
                root = DEFAULT_PROTOCOL + root;
            }
            if (root && !/service\/?$/i.test(root)) {
                root = root + "/service/";
            }
            if (properties.errorHandler) {
                this.errorHandler = properties.errorHandler;
            } else {
                this.errorHandler = function(err, text) {
                    console.log(err);
                    if (text) {
                        console.log(text);
                    }
                    console.log(err.stack ? err.stack : "");
                };
            }
            this.root = root;
            this.token = properties.token
            this.DEBUG = properties.debug || false;
            this.help = properties.help || 'no.help.available@dev.null'

            _.bindAll(this, "fetchVersion", "rows", "records", "fetchTemplates", "fetchLists", 
                "count", "makeRequest", "fetchModel", "fetchSummaryFields", "combineLists", 
                "merge", "intersect", "diff", "query", "whoami");

        }, this);

        this.fetchVersion = function(cb) {
            var self = this;
            var promise = Deferred();
            if (typeof this.version === "undefined") {
                this.makeRequest(VERSION_PATH, null, function(data) {
                    this.version = data.version;
                    cb(this.version);
                }).fail(promise.reject);
            } else {
                cb(this.version);
                promise.resolve(this.version);
            }
            return promise;
        };

        this.fetchTemplates = function(cb) {
            var promise = Deferred();
            this.makeRequest(TEMPLATES_PATH, null, function(data) {
                cb(data.templates);
                promise.resolve(data.templates);
            }).fail(promise.reject);
            promise.fail(this.errorHandler);
            return promise;
        };

        this.fetchLists = function(cb) {
            var self = this;
            var promise = Deferred();
            this.makeRequest(LISTS_PATH, null, function(data) {
                var lists = _(data.lists).map(function (l) {return new List(l, self)});
                cb(lists);
                promise.resolve(lists);
            }).fail(promise.reject);
            promise.fail(this.errorHandler);
            return promise;
        };

        this.combineLists = function(operation) {
            var self = this;
            return function(options, cb) {
                var promise = Deferred();
                var path = LIST_OPERATION_PATHS[operation];
                var params = {
                    name: options.name,
                    tags: options.tags.join(';'),
                    lists: options.lists.join(";"),
                    description: options.description
                };
                self.makeRequest(path, params, function(data) {
                    var name = data.listName;
                    self.fetchLists(function(ls) {
                        var l = _(ls).find(function(l) {return l.name === name});
                        cb(l);
                        promise.resolve(l);
                    }).fail(promise.reject);
                }).fail(promise.reject);
                promise.fail(self.errorHandler);
                return promise;
            };
        };

        this.merge = this.combineLists("merge");
        this.intersect = this.combineLists("intersect");
        this.diff = this.combineLists("diff");

        this.fetchModel = function(cb) {
            var self = this;
            var promise = Deferred();
            if (MODELS[self.root]) {
                self.model = MODELS[self.root];
            }
            if (self.model) {
                cb(self.model);
                promise.resolve(self.model);
            } else {
                this.makeRequest(MODEL_PATH, null, function(data) {
                    if (Model) {
                        self.model = new Model(data.model);
                    } else {
                        self.model = data.model;
                    }
                    self.model.service = self;
                    MODELS[self.root] = self.model;
                    cb(self.model);
                    promise.resolve(self.model);
                }).fail(promise.reject);
            }
            return promise;
        };

        this.fetchSummaryFields = function(cb) {
            var self = this;
            var promise = Deferred();
            if (SUMMARY_FIELDS[self.root]) {
                self.summaryFields = SUMMARY_FIELDS[self.root];
            }
            if (self.summaryFields) {
                cb(self.summaryFields);
                promise.resolve(self.summaryFields);
            } else {
                self.makeRequest(SUMMARYFIELDS_PATH, null, function(data) {
                    self.summaryFields = data.classes;
                    SUMMARY_FIELDS[self.root] = data.classes;
                    cb(self.summaryFields);
                    promise.resolve(self.summaryFields);
                });
            }
            promise.fail(this.errorHandler);
            return promise;
        };

        /**
        * Fetch lists containing an item.
        *
        * @param options Options should contain: 
        *  - either:
        *    * id: The internal id of the object in question
        *  - or: 
        *    * publicId: An identifier
        *    * type: The type of object (eg. "Gene")
        *    * extraValue: (optional) A domain to help resolve the object (eg an organism for a gene).
        *
        *  @param cb function of the type: [List] -> ()
        *  @return A promise
        */
        this.fetchListsContaining = function(opts, cb) {
            cb = cb || function() {};
            return this.makeRequest(WITH_OBJ_PATH, opts, function(data) {cb(data.lists)});
        };


        this.query = function(options, cb) {
            var service = this;
            var promise = Deferred();
            service.fetchModel(function(m) {
                service.fetchSummaryFields(function(sfs) {
                    _.defaults(options, {model: m, summaryFields: sfs});
                    var q;
                    try {
                        q = new Query(options, service);
                    } catch (e) {
                        promise.reject(e);
                    }
                    if (cb) {
                        try {
                            cb(q);
                        } catch (e) {
                            promise.reject(e);
                        }
                    }
                    promise.resolve(q);
                }).fail(promise.reject);
            }).fail(promise.reject);
            promise.fail(this.errorHandler);
            return promise;
        };

        constructor(properties || {});
    };

    exports.Service = Service;
    if (IS_NODE) {
        exports.Model = Model;
        exports.Query = Query;
        exports.List = List;
    }
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');

        
// Generated by CoffeeScript 1.3.3
(function() {
  var IS_NODE, Query, conStr, conValStr, concatMap, decapitate, f, fold, getListResponseHandler, get_canonical_op, id, mth, multiConStr, partition, root, simpleConStr, take, toQueryString, _, _CLONE, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === 'undefined') {
    IS_NODE = false;
    _ = root._;
    _ref = root._func_shiv, partition = _ref.partition, fold = _ref.fold, take = _ref.take, concatMap = _ref.concatMap, id = _ref.id;
    _CLONE = function(o) {
      return jQuery.extend(true, {}, o);
    };
    toQueryString = function(req) {
      return jQuery.param(req);
    };
    if (typeof root.console === 'undefined') {
      root.console = {
        log: function() {},
        error: function() {}
      };
    }
    if (root.intermine === 'undefined') {
      root.intermine = {};
    }
    root = root.intermine;
  } else {
    IS_NODE = true;
    _ = require('underscore')._;
    _CLONE = require('clone');
    toQueryString = require('querystring').stringify;
    _ref1 = require('./shiv'), partition = _ref1.partition, fold = _ref1.fold, take = _ref1.take, concatMap = _ref1.concatMap, id = _ref1.id;
  }

  get_canonical_op = function(orig) {
    var canonical;
    canonical = _.isString(orig) ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw "Illegal constraint operator: " + orig;
    }
    return canonical;
  };

  decapitate = function(x) {
    return x.substr(x.indexOf('.'));
  };

  getListResponseHandler = function(service, cb) {
    return function(data) {
      var name;
      if (cb == null) {
        cb = function() {};
      }
      name = data.listName;
      return service.fetchLists(function(ls) {
        var theList;
        theList = _.find(ls, function(l) {
          return l.name === name;
        });
        return cb(theList);
      });
    };
  };

  conValStr = function(v) {
    return "<value>" + (_.escape(v)) + "</value>";
  };

  simpleConStr = function(c) {
    var k, v;
    return "<constraint " + (((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        _results.push(k + '="' + _.escape(v) + '"');
      }
      return _results;
    })()).join(' ')) + " />";
  };

  multiConStr = function(c) {
    return "<constraint path=\"" + c.path + "\" op=\"" + (_.escape(c.op)) + "\">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  conStr = function(c) {
    if (c.values != null) {
      return multiConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  Query = (function() {

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      "=": "=",
      "==": "=",
      "eq": "=",
      "!=": "!=",
      "ne": "!=",
      ">": ">",
      "gt": ">",
      ">=": ">=",
      "ge": ">=",
      "<": "<",
      "lt": "<",
      "<=": "<=",
      "le": "<=",
      "contains": "CONTAINS",
      "like": "LIKE",
      "lookup": "LOOKUP",
      "IS NULL": "IS NULL",
      "is null": "IS NULL",
      "IS NOT NULL": "IS NOT NULL",
      "is not null": "IS NOT NULL",
      "ONE OF": "ONE OF",
      "one of": "ONE OF",
      "NONE OF": "NONE OF",
      "none of": "NONE OF",
      "in": "IN",
      "not in": "IN",
      "IN": "IN",
      "NOT IN": "NOT IN"
    };

    Query.prototype.on = function(events, callback, context) {
      var calls, ev, list, tail, _ref2, _ref3, _ref4;
      events = events.split(/\s+/);
      calls = ((_ref2 = this._callbacks) != null ? _ref2 : this._callbacks = {});
      while (ev = events.shift()) {
        list = ((_ref3 = calls[ev]) != null ? _ref3 : calls[ev] = {});
        tail = ((_ref4 = list.tail) != null ? _ref4 : list.tail = (list.next = {}));
        tail.callback = callback;
        tail.context = context;
        list.tail = tail.next = {};
      }
      return this;
    };

    Query.prototype.bind = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.on.apply(this, args);
    };

    Query.prototype.trigger = function() {
      var all, args, calls, event, events, node, rest, tail;
      events = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      calls = this._callbacks;
      if (!calls) {
        return this;
      }
      all = calls['all'];
      (events = events.split(/\s+/)).push(null);
      while (event = events.shift()) {
        if (all) {
          events.push({
            next: all.next,
            tail: all.tail,
            event: event
          });
        }
        if (!(node = calls[event])) {
          continue;
        }
        events.push({
          next: node.next,
          tail: node.tail
        });
      }
      while (node = events.pop()) {
        tail = node.tail;
        args = node.event ? [node.event].concat(rest) : rest;
        while ((node = node.next) !== tail) {
          node.callback.apply(node.context || this, args);
        }
      }
      return this;
    };

    function Query(properties, service) {
      this.expandStar = __bind(this.expandStar, this);

      this.adjustPath = __bind(this.adjustPath, this);

      var _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      _.defaults(this, {
        constraints: [],
        views: [],
        joins: {},
        constraintLogic: "",
        sortOrder: ""
      });
      if (properties == null) {
        properties = {};
      }
      this.service = service != null ? service : {};
      this.model = (_ref2 = properties.model) != null ? _ref2 : {};
      this.summaryFields = (_ref3 = properties.summaryFields) != null ? _ref3 : {};
      this.root = (_ref4 = properties.root) != null ? _ref4 : properties.from;
      this.maxRows = (_ref5 = (_ref6 = properties.size) != null ? _ref6 : properties.limit) != null ? _ref5 : properties.maxRows;
      this.start = (_ref7 = (_ref8 = properties.start) != null ? _ref8 : properties.offset) != null ? _ref7 : 0;
      this.select(properties.views || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      unwanted = _.isString(unwanted) ? [unwanted] : unwanted || [];
      mapFn = _.compose(this.expandStar, this.adjustPath);
      unwanted = _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref2, _ref3, _results;
        _ref2 = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          so = _ref2[_i];
          if (!(_ref3 = so.path, __indexOf.call(unwanted, _ref3) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.views;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          v = _ref2[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      return this.trigger('change:views', this.views);
    };

    Query.prototype.removeConstraint = function(con) {
      var c, iscon, orig, reduced;
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref2, _ref3;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref2 = c.values) != null ? _ref2.join('%%') : void 0) === ((_ref3 = con.values) != null ? _ref3.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
      }
      this.constraints = reduced;
      this.trigger('change:constraints');
      return this.trigger('removed:constraints', _.difference(orig, reduced));
    };

    Query.prototype.addToSelect = function(views) {
      var p, toAdd, _i, _len, _ref2;
      views = _.isString(views) ? [views] : views || [];
      toAdd = _.map(views, _.compose(this.expandStar, this.adjustPath));
      _ref2 = _.flatten([toAdd]);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        this.views.push(p);
      }
      return this.trigger('add:view change:views', toAdd);
    };

    Query.prototype.select = function(views) {
      var v, _i, _len;
      this.views = [];
      for (_i = 0, _len = views.length; _i < _len; _i++) {
        v = views[_i];
        this.addToSelect(v);
      }
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype._getAllFields = function(table) {
      var attrs, cols, refs;
      attrs = _.values(table.attributes);
      refs = _.values(table.references);
      cols = _.values(table.collections);
      return _.union(attrs, refs, cols);
    };

    Query.prototype._getPaths = function(root, cd, depth) {
      var others, ret, self;
      self = this;
      ret = [root];
      others = [];
      if (cd && depth > 0) {
        others = _.flatten(_.map(cd.fields, function(r) {
          return self._getPaths("" + root + "." + r.name, self.getPathInfo("" + root + "." + r.name).getEndClass(), depth - 1);
        }));
      }
      return ret.concat(others);
    };

    Query.prototype.getPossiblePaths = function(depth) {
      var cd, _base, _ref2, _ref3;
      if (depth == null) {
        depth = 3;
      }
      if ((_ref2 = this._possiblePaths) == null) {
        this._possiblePaths = {};
      }
      cd = this.service.model.classes[this.root];
      return (_ref3 = (_base = this._possiblePaths)[depth]) != null ? _ref3 : _base[depth] = _.flatten(this._getPaths(this.root, cd, depth));
    };

    Query.prototype.getPathInfo = function(path) {
      var _ref2;
      return (_ref2 = this.service.model) != null ? _ref2.getPathInfo(this.adjustPath(path), this.getSubclasses()) : void 0;
    };

    Query.prototype.getSubclasses = function() {
      return fold({}, (function(a, c) {
        if (c.type != null) {
          a[c.path] = c.type;
        }
        return a;
      }))(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function(path) {
      var toParentNode,
        _this = this;
      toParentNode = function(v) {
        return _this.getPathInfo(v).getParent();
      };
      return _.uniq(_.map(this.views, toParentNode), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.service.model.hasCollection(this.adjustPath(path));
    };

    Query.prototype.getQueryNodes = function() {
      var constrainedNodes, viewNodes,
        _this = this;
      viewNodes = this.getViewNodes();
      constrainedNodes = _.map(this.constraints, function(c) {
        var pi;
        pi = _this.getPathInfo(c.path);
        if (pi.isAttribute()) {
          return pi.getParent();
        } else {
          return pi;
        }
      });
      return _.uniq(viewNodes.concat(constrainedNodes), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.expandStar = function(path) {
      var cd, expand, fn, n, pathStem;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = _.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref2, _results;
              _ref2 = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                n = _ref2[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        }
        if (/\.\*\*$/.test(path)) {
          fn = _.compose(expand, function(a) {
            return '.' + a.name;
          });
          return _.uniq(_.union(this.expandStar(pathStem + '.*'), _.map(cd.attributes, fn)));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      return this.views && _.include(this.views, this.adjustPath(v));
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, req, toRun, wrapped;
      name = target && target.name ? target.name : '' + target;
      toRun = this.clone();
      if (toRun.views.length !== 1 || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = {
        listName: name,
        query: toRun.toXML()
      };
      wrapped = target && target.name ? (function(list) {
        target.size = list.size;
        return cb(list);
      }) : cb;
      return this.service.makeRequest('query/append/tolist', req, getListResponseHandler(this.service, wrapped), 'POST');
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.clone();
      if (toRun.views.length !== 1 || toRun.views[0] === null || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = _.clone(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return this.service.makeRequest('query/tolist', req, getListResponseHandler(this.service, cb), 'POST');
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var req, toRun;
      if (_.isFunction(limit) && !cont) {
        cont = limit;
        limit = null;
      }
      if (cont == null) {
        cont = function() {};
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (!_.include(toRun.views, path)) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        format: 'jsonrows',
        summaryPath: path
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      return this.service.makeRequest('query/results', req, function(data) {
        return cont(data.results, data.uniqueValues, data.filteredCount);
      });
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned;
      cloned = _CLONE(this);
      if (!cloneEvents) {
        cloned._callbacks = {};
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(path) {
      var dir, so, _i, _len, _ref2;
      path = this.adjustPath(path);
      _ref2 = this.sortOrder;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        so = _ref2[_i];
        if (so.path === path) {
          dir = so.direction;
        }
      }
      return dir;
    };

    Query.prototype.isOuterJoined = function(path) {
      path = this.adjustPath(path);
      return _.any(this.joins, function(d, p) {
        return d === 'OUTER' && path.indexOf(p) === 0;
      });
    };

    Query.prototype._parse_sort_order = function(input) {
      var k, so, v;
      so = input;
      if (_.isString(input)) {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (!(input.path != null)) {
        k = _.keys(input)[0];
        v = _.values(input)[0];
        so = {
          path: k,
          direction: v
        };
      }
      so.path = this.adjustPath(so.path);
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe, _i, _len, _ref2;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (!(currentDirection != null)) {
        return this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        _ref2 = this.sortOrder;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          oe = _ref2[_i];
          if (oe.path === so.path) {
            oe.direction = so.direction;
          }
        }
        return this.trigger('change:sortorder', this.sortOrder);
      }
    };

    Query.prototype.addSortOrder = function(so) {
      this.sortOrder.push(this._parse_sort_order(so));
      this.trigger('add:sortorder', so);
      return this.trigger('change:sortorder', this.sortOrder);
    };

    Query.prototype.orderBy = function(oes) {
      var oe, _i, _len;
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(oe);
      }
      return this.trigger('set:sortorder', this.sortOrder);
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (_.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      var _ref2, _ref3, _ref4;
      if (_.isString(join)) {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      join.path = this.adjustPath(join.path);
      join.style = (_ref2 = (_ref3 = join.style) != null ? _ref3.toUpperCase() : void 0) != null ? _ref2 : join.style;
      if (_ref4 = join.style, __indexOf.call(Query.JOIN_STYLES, _ref4) < 0) {
        throw "Invalid join style: " + join.style;
      }
      this.joins[join.path] = join.style;
      return this.trigger('set:join', join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints) {
      var c, con, path, _fn, _i, _len,
        _this = this;
      this.__silent__ = true;
      if (_.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c);
        }
      } else {
        _fn = function(path, con) {
          var constraint, k, keys, v, x, _ref2;
          constraint = {
            path: path
          };
          if (con === null) {
            constraint.op = 'IS NULL';
          } else if (_.isArray(con)) {
            constraint.op = 'ONE OF';
            constraint.values = con;
          } else if (_.isString(con) || _.isNumber(con)) {
            if (_ref2 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
              constraint.op = con;
            } else {
              constraint.op = '=';
              constraint.value = con;
            }
          } else {
            keys = (function() {
              var _results;
              _results = [];
              for (k in con) {
                x = con[k];
                _results.push(k);
              }
              return _results;
            })();
            if (__indexOf.call(keys, 'isa') >= 0) {
              constraint.type = con.isa;
            } else {
              if (__indexOf.call(keys, 'extraValue') >= 0) {
                constraint.extraValue = con.extraValue;
              }
              for (k in con) {
                v = con[k];
                if (!(k !== 'extraValue')) {
                  continue;
                }
                constraint.op = k;
                constraint.value = v;
              }
            }
          }
          return _this.addConstraint(constraint);
        };
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      return this.trigger('change:constraints');
    };

    Query.prototype.addConstraint = function(constraint) {
      var a0, conArgs, v, _ref2;
      if (_.isArray(constraint)) {
        conArgs = constraint.slice();
        constraint = {
          path: conArgs.shift()
        };
        if (conArgs.length === 1) {
          a0 = conArgs[0];
          if (_ref2 = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
            constraint.op = a0;
          } else {
            constraint.type = a0;
          }
        } else if (conArgs.length >= 2) {
          constraint.op = conArgs[0];
          v = conArgs[1];
          if (_.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
          if (conArgs.length === 3) {
            constraint.extraValue = conArgs[2];
          }
        }
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        try {
          constraint.op = get_canonical_op(constraint.op);
        } catch (error) {
          throw new Error("Illegal operator: " + constraint.op);
        }
      }
      this.constraints.push(constraint);
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return this.sortOrder.map(function(oe) {
        return "" + oe.path + " " + oe.direction;
      }).join(' ');
    };

    Query.prototype.getConstraintXML = function() {
      if (this.constraints.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(this.constraints)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref2, _results;
        _ref2 = this.joins;
        _results = [];
        for (p in _ref2) {
          s = _ref2[p];
          if (this.isRelevant(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.isRelevant = function(p) {
      var pi, pstr;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        return _.any(_.union(this.views, _.pluck(this.constraints, 'path')), function(p) {
          return p.indexOf(pstr) === 0;
        });
      } else {
        return true;
      }
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      if (cb == null) {
        cb = function() {};
      }
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'json'
      };
      return this.service.makeRequest('query/code', req, function(data) {
        return cb(data.code);
      });
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref2;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format) {
      var req, _ref2;
      if (format == null) {
        format = 'tab';
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"]();
      }
      req = {
        query: this.toXML(),
        format: format
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.__bio_req = function(types, n) {
      var olds, toRun,
        _this = this;
      toRun = this.clone();
      olds = toRun.views;
      toRun.views = take(n)(olds.map(function(v) {
        return _this.getPathInfo(v).getParent();
      }).filter(function(p) {
        return _.any(types, function(t) {
          return p.isa(t);
        });
      }).map(function(p) {
        return p.append('primaryIdentifier').toPathString();
      }));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  Query.ATTRIBUTE_OPS = _.union(Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS);

  Query.REFERENCE_OPS = _.union(Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS);

  _ref2 = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = function(cb) {
      var req;
      req = this[reqMeth]();
      if (cb == null) {
        cb = function() {};
      }
      return this.service.makeRequest('query/results/' + f, req, cb, 'POST');
    };
    return Query.prototype[uriMeth] = function(cb) {
      var req, _ref3;
      req = this[reqMeth]();
      if (((_ref3 = this.service) != null ? _ref3.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    };
  };
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    f = _ref2[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function(page, cb) {
      if (cb == null) {
        cb = page;
      }
      page = _.isFunction(page) || !page ? {} : page;
      if (this.service[server_fn]) {
        _.defaults(page, {
          start: this.start,
          size: this.maxRows
        });
        return this.service[server_fn](this, page, cb);
      } else {
        throw new Error("Could not find " + server_fn + " at this service. Sorry.");
      }
    };
  };

  _ref3 = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows'];
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    mth = _ref3[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  root.Query = Query;

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    var _;
    if (IS_NODE) {
        _ = require('underscore')._;
    } else {
        _ = exports._;
        if (typeof exports.intermine == 'undefined') {
            exports.intermine = {};
        }
        exports = intermine;
    }

    var List = function(properties, service) {

        _(this).extend(properties);
        this.service = service;
        this.dateCreated = this.dateCreated ? new Date(this.dateCreated) : null;

        var isFolder = function(t) {
            return t.substr(0, t.indexOf(":")) === '__folder__';
        };
        var getFolderName = function(t) {
            return t.substr(t.indexOf(":") + 1);
        };

        this.folders = _(this.tags).chain()
                                   .filter(isFolder)
                                   .map(getFolderName)
                                   .value();
        
        this.hasTag = function(t) {
            return _(this.tags).include(t);
        };

        this.del = function(cb) {
            cb = cb || function() {};
            return this.service.makeRequest("lists", 
                {name: this.name}, cb, "DELETE");
        };

        this.contents = function(cb) {
            cb = cb || function() {};
            var query = {select: ["*"], from: this.type, where: {}};
            query.where[this.type] = {IN: this.name};
            return this.service.query(query, function(q) {
                q.records(cb);
            });
        };

        this.enrichment = function(data, cb) {
            data.list = this.name;
            return this.service.enrichment(data, cb);
        };
    };

    exports.List = List;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');
        
